// This code is available on the terms of the project LICENSE.md file,
// also available online at https://blueoakcouncil.org/license/1.0.0.

// Package rpcserver provides a JSON RPC to communicate with the client core.
package rpcserver

import (
	"context"
	"crypto/elliptic"
	"crypto/sha256"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"decred.org/dcrdex/client/core"
	"decred.org/dcrdex/dex/msgjson"
	"github.com/decred/dcrd/certgen"
	"github.com/decred/slog"
	"github.com/go-chi/chi"
	"github.com/go-chi/chi/middleware"
)

const (
	// rpcTimeoutSeconds is the number of seconds a connection to the
	// RPC server is allowed to stay open without authenticating before it
	// is closed.
	rpcTimeoutSeconds = 10

	// RPC version
	rpcSemverMajor = 0
	rpcSemverMinor = 0
	rpcSemverPatch = 0
)

var log slog.Logger

// clientCore is satisfied by core.Core.
type clientCore interface {
	ListMarkets() []*core.MarketInfo
	Register(*core.Registration) error
	Login(dex, pw string) error
	Sync(dex string, base, quote uint32) (chan *core.BookUpdate, error)
	Book(dex string, base, quote uint32) *core.OrderBook
	Unsync(dex string, base, quote uint32)
	Balance(uint32) (uint64, error)
}

// marketSyncer is used to synchronize market subscriptions. The marketSyncer
// manages a map of clients who are subscribed to the market, and distributes
// order book updates when received.
type marketSyncer struct {
	mtx     sync.Mutex
	core    clientCore
	dex     string
	base    uint32
	quote   uint32
	clients map[int32]*wsClient
}

// newMarketSyncer is the constructor for a marketSyncer.
func newMarketSyncer(ctx context.Context, core clientCore, dex string, base, quote uint32) (*marketSyncer, error) {
	m := &marketSyncer{
		core:    core,
		dex:     dex,
		base:    base,
		quote:   quote,
		clients: make(map[int32]*wsClient),
	}

	// Get an updates channel, and begin syncing the book.
	updates, err := core.Sync(dex, base, quote)
	if err != nil {
		return nil, err
	}

	go func() {
		log.Debugf("monitoring market %d-%d @ %s", base, quote, dex)
	out:
		for {
			select {
			case update := <-updates:
				// Distribute the book to the subscribed clients.
				log.Tracef("order book update received for " + update.Market)
			case <-ctx.Done():
				break out
			}
		}
	}()
	return m, nil
}

// add adds a client to the client map, and returns a fresh orderbook.
func (m *marketSyncer) add(cl *wsClient) *core.OrderBook {
	m.mtx.Lock()
	m.clients[cl.cid] = cl
	m.mtx.Unlock()
	return m.core.Book(m.dex, m.base, m.quote)
}

// remove removes a client from the client map. If this is the last client,
// the market will be "unsynced".
func (m *marketSyncer) remove(cl *wsClient) {
	m.mtx.Lock()
	defer m.mtx.Unlock()
	delete(m.clients, cl.cid)
	if len(m.clients) == 0 {
		m.core.Unsync(m.dex, m.base, m.quote)
	}
}

// RPCServer is a single-client http and websocket server enabling a JSON
// interface to the DEX client.
type RPCServer struct {
	ctx      context.Context
	core     clientCore
	listener net.Listener
	srv      *http.Server
	authsha  [32]byte
	mtx      sync.RWMutex
	syncers  map[string]*marketSyncer
	clients  map[int32]*wsClient
}

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string) error {
	log.Infof("Generating TLS certificates...")

	org := "dcrdex autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := certgen.NewTLSCertPair(elliptic.P521(), org,
		validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0644); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	log.Infof("Done generating TLS certificates")
	return nil
}

// handler is the type for functions that handle RPC requests.
type handler func(s *RPCServer, ws *wsClient, msg *msgjson.Message) *msgjson.Error

// routes maps routes to their handler.
var routes = map[string]handler{
	"help":    handleHelp,
	"version": handleVersion,
}

// writeJSON marshals the provided interface and writes the bytes to the
// ResponseWriter. The response code is assumed to be StatusOK.
func writeJSON(w http.ResponseWriter, thing interface{}) {
	writeJSONWithStatus(w, thing, http.StatusOK)
}

// writeJSON writes marshals the provided interface and writes the bytes to the
// ResponseWriter with the specified response code.
func writeJSONWithStatus(w http.ResponseWriter, thing interface{}, code int) {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(code)
	encoder := json.NewEncoder(w)
	if err := encoder.Encode(thing); err != nil {
		log.Infof("JSON encode error: %v", err)
	}
}

// handleJSON handles all https json requests.
func (s *RPCServer) handleJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Connection", "close")
	w.Header().Set("Content-Type", "application/json")
	r.Close = true

	msg := s.parseHTTPRequest(r)
	writeJSON(w, msg)
}

// New is the constructor for a new RPCServer.
func New(core clientCore, addr, user, pass, cert, key string, logger slog.Logger) (*RPCServer, error) {
	log = logger

	// Find or create the key pair.
	keyExists := fileExists(key)
	certExists := fileExists(cert)
	if certExists == !keyExists {
		return nil, fmt.Errorf("missing cert pair file")
	}
	if !keyExists && !certExists {
		err := genCertPair(cert, key)
		if err != nil {
			return nil, err
		}
	}
	keypair, err := tls.LoadX509KeyPair(cert, key)
	if err != nil {
		return nil, err
	}

	// Prepare the TLS configuration.
	tlsConfig := tls.Config{
		Certificates: []tls.Certificate{keypair},
		MinVersion:   tls.VersionTLS12,
	}

	// Create listener.
	listener, err := tls.Listen("tcp4", addr, &tlsConfig)
	if err != nil {
		return nil, fmt.Errorf("Can't listen on %s. web server quitting: %v", addr, err)
	}

	// Create an HTTP router.
	mux := chi.NewRouter()
	httpServer := &http.Server{
		Handler:      mux,
		ReadTimeout:  rpcTimeoutSeconds * time.Second, // slow requests should not hold connections opened
		WriteTimeout: rpcTimeoutSeconds * time.Second, // hung responses must die
	}

	// Make the server.
	s := &RPCServer{
		core:     core,
		listener: listener,
		srv:      httpServer,
		syncers:  make(map[string]*marketSyncer),
		clients:  make(map[int32]*wsClient),
	}

	// Create authsha to verify requests against.
	if user != "" && pass != "" {
		login := user + ":" + pass
		auth := "Basic " +
			base64.StdEncoding.EncodeToString([]byte(login))
		s.authsha = sha256.Sum256([]byte(auth))
	}

	// Middleware
	mux.Use(middleware.Recoverer)
	mux.Use(middleware.RealIP)
	mux.Use(s.authMiddleware)

	// Websocket endpoint
	mux.Get("/ws", s.handleWS)

	// https endpoint
	mux.Post("/", s.handleJSON)

	return s, nil
}

// Run starts the web server. Satisfies the runner.Runner interface.
func (s *RPCServer) Run(ctx context.Context) {
	s.ctx = ctx
	// Close the listener on context cancellation.
	go func() {
		<-ctx.Done()
		err := s.listener.Close()
		if err != nil {
			log.Errorf("Problem shutting down rpc: %v", err)
		}
		s.mtx.Lock()
		defer s.mtx.Unlock()
		for _, cl := range s.clients {
			cl.Disconnect()
		}
	}()
	log.Infof("RPC server listening on %s", s.listener.Addr())
	err := s.srv.Serve(s.listener)
	if err != http.ErrServerClosed {
		log.Warnf("unexpected (http.Server).Serve error: %v", err)
	}
	log.Infof("RPC server off")
}

// watchMarket watches the specified market. A fresh order book and a quit
// function are returned on success. The quit function should be called to
// unsubsribe the client from the market.
func (s *RPCServer) watchMarket(cl *wsClient, dex string, base, quote uint32) (book *core.OrderBook, quit func(), err error) {
	s.mtx.Lock()
	defer s.mtx.Unlock()
	mktID := marketID(base, quote)
	syncer, found := s.syncers[mktID]
	if !found {
		syncer, err = newMarketSyncer(s.ctx, s.core, dex, base, quote)
		if err != nil {
			return
		}
		s.syncers[mktID] = syncer
	}
	book = syncer.add(cl)
	return book, func() {
		syncer.remove(cl)
	}, nil
}

// handleRequest sends the request to the correct handler function if able.
func (s *RPCServer) handleRequest(cl *wsClient, req *msgjson.Message) *msgjson.Error {
	if req.Route == "" {
		log.Debugf("received empty request")
		return msgjson.NewError(msgjson.RPCErrorUnspecified, "no route was supplied")
	}

	// Find the correct handler for this route.
	h, ok := routes[req.Route]

	// If this is a ws request, check ws routes.
	if !ok && cl != nil {
		h, ok = wsHandlers[req.Route]
	}

	if !ok {
		log.Debugf("could not find route: %v", req.Route)
		return msgjson.NewError(msgjson.RPCUnknownRoute, "unknown route")
	}

	// req will be populated with a response after this.
	return h(s, cl, req)
}

// parseRequest parses the msgjson message in the request body and creates a
// response message.
func (s *RPCServer) parseHTTPRequest(r *http.Request) (msg *msgjson.Message) {
	msg = &msgjson.Message{Type: msgjson.Response}
	payload := new(msgjson.ResponsePayload)

	// This will be filled with the msgjson request.
	req := new(msgjson.Message)

	defer func() {
		// If an error was encountered, marshal the payload, otherwise
		// the handler will take care of it.
		if payload.Error != nil {
			p, err := encode(req.Route, payload)
			if err != nil {
				msg.Payload = encodingFailurePayload
			}
			msg.Payload = p
		} else {
			// If no error was encountered, req has been filled with
			// a response.
			*msg = *req
		}
	}()

	// Read the request.
	body, err := ioutil.ReadAll(r.Body)
	r.Body.Close()
	if err != nil {
		log.Debugf("Error reading request body: %v", err)
		payload.Error = msgjson.NewError(msgjson.RPCParseError, "unable to parse request")
		return
	}
	err = json.Unmarshal(body, req)
	if err != nil {
		log.Debugf("failed to unmarshal JSON request: %v", err)
		payload.Error = msgjson.NewError(msgjson.RPCParseError, "unable to parse request")
		return
	}
	log.Tracef("message received for route: %s", req.Route)

	// Send back the same ID.
	msg.ID = req.ID
	if req.Type != msgjson.Request {
		log.Debugf("wrong type: %d", req.Type)
		errMsg := fmt.Sprintf("wrong or unknown message type specified, must be %d for requests", msgjson.Request)
		payload.Error = msgjson.NewError(msgjson.UnknownMessageType, errMsg)
		return
	}
	payload.Error = s.handleRequest(nil, req)
	return
}

// authMiddleware checks incoming requests for authentication.
func (s *RPCServer) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		auth := r.Header["Authorization"]
		if len(auth) == 0 || s.authsha != sha256.Sum256([]byte(auth[0])) {
			log.Warnf("authentication failure from ip: %s with auth: %s", r.RemoteAddr, auth)
			w.Header().Add("WWW-Authenticate", `Basic realm="dex RPC"`)
			http.Error(w, "401 Unauthorized.", http.StatusUnauthorized)
			return
		}
		log.Tracef("authenticated user with ip: %s", r.RemoteAddr)
		next.ServeHTTP(w, r)
	})
}

// filesExists reports whether the named file or directory exists.
func fileExists(name string) bool {
	_, err := os.Stat(name)
	return !os.IsNotExist(err)
}

// Create a unique ID for a market.
func marketID(base, quote uint32) string {
	return strconv.Itoa(int(base)) + "_" + strconv.Itoa(int(quote))
}
